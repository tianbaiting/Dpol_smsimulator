# 2025 12 月 notebook

## 2025-12-02

更换了qmd特征动量的大小,从600MeV/c改为627MeV/c,以更好地匹配实验数据.

Changed the QMD characteristic momentum from 600 MeV/c to 627 MeV/c to better match experimental data.

$P = \sqrt{(E)^2 - (m)^2} = \sqrt{(190+938)^2 - (938)^2} MeV/c = 625.5MeV/c$

## 2025-12-03

change homebrew g++ cmake root to conda-forge versions.

use micromaba . .yml to create a env for anaroot . useing root and geant4 in conda-forge

```yml
name: anaroot-env
channels:
  - conda-forge
dependencies:
  - python=3.10
  - cmake
  - make
  - git
  - wget
  - pkg-config
  - gcc_linux-64
  - gxx_linux-64
  - root
  - geant4
  - xerces-c
  - fftw
  - gsl
  - libxml2
  - libpng
  - zlib
  - swig
  - pip
  - xorg-libx11
  - xorg-libxpm
  - xorg-libxft

```

```
# 初始化 micromamba
eval "$(micromamba shell hook -s bash)"  # 或 -s zsh

可选：自动激活 anaroot 环境
micromamba activate anaroot-env
```


direnv is an open-source extension that automatically loads and executes the environment variables and scripts defined in a .envrc file when you enter (cd into) a directory containing one. It automatically unloads those variables when you leave the directory.

```
# Auto-generated .envrc for Dpol_smsimulator
# This file will be executed by direnv when you cd into the project root.
# Ensure micromamba is initialized in this shell (zsh) before using `micromamba activate`.
# Keep this file small and review before allowing with `direnv allow`.

# Initialize micromamba shell hook for zsh (direnv runs this file with your login shell)
if command -v micromamba >/dev/null 2>&1; then
  eval "$(micromamba shell hook --shell zsh)"
fi

# Source the project setup which performs activation and exports variables
if [[ -f ./setup_spana.sh ]]; then
  source ./setup_spana.sh
fi
```


## 2025-12-05

我希望调大动量范围。 

todo 探寻质子动量空间（可被接受的空间）画出三维空间图来，以及做出来此时的pxp-pxn (无模糊 只filter)

取样好还是参数取点好。 

数据的透明选择,root如何做到

I want to increase the momentum range. TODO: Explore the acceptable proton momentum space, visualize it in a 3D plot, and calculate $p_{p} - p_{n}$ (without blurring, only filtering). Which is better: sampling or parametric point scanning?



```bash
root -b -q $ROOTSYS/tutorials/legacy/benchmarks.C > rootbenchmarktest.txt
```

| name | root benchmark | cpu | description |   
|------|-----------------|-----|-------------|
| RIBFANA 04 | 5022 | Intel Xeon Gold 5218 @ 2.30GHz | riken |
| spana03| 4972 | Intel Xeon Platinum 8168 @ 2.70GHz | riken |
| ENPG | 2186 | Intel Xeon E5-2650 v4 @ 2.20GHz | zhigang group |
| SER5 MAX | 19444 | AMD Ryzen 7 5700H | tbt pc |
| Thinkpad X1 Carbon gen10 | 4945 | i7-1260P | tbt pc |

## 2025-12-9

使用hostname 为不同机器加载不同的软件路径

查看root数据文件, 


## 2025-12-10

try to fix root .

.root 文件被 TBrowser 打开 自动展开嵌套, 加载自定义类. 需要利用反射机制. 

geant4 nebula里面似乎没有这样的实现.  


https://tianbaiting.github.io/sci/minimal_code/cernrootData/


提出的这个问题非常关键，它直指 ROOT I/O 的核心——数据透明化（Inspectability），这对于粒子物理学中的数据审查和调试是至关重要的。

您在 TBrowser 中无法查看自定义类内部变量的数值，其根本原因在于 ROOT 缺乏读取和理解该对象内存结构所需的“路线图”。这个“路线图”就是我们昨天谈到的字典以及由它衍生出的 Streamer Information（流信息）。

下面我将详细解释如何满足“透明化”要求，并给出具体的检查步骤。

解决 ROOT 数据透明化的核心方法
要让 TBrowser 或任何 ROOT I/O 函数（如 TTree::Scan()）能够“透明化”地访问自定义 C++ 类的内部变量，必须满足以下两个条件：

1. 确保类和成员变量拥有完整的字典和流信息
流信息（Streamer Information） 是字典机制的核心输出，它包含了 ROOT 在运行时读取和写入对象所需的所有元数据：

类的版本号 (ClassVersion)

所有非 static 和非 transient 的数据成员的列表。

每个数据成员的类型、偏移量（offset in memory）和名称。

如果 Streamer Info 不完整或缺失，TBrowser 只能看到一个抽象的类对象（例如 MyEvent* 或 MyHit），但无法“展开”它来看里面的变量。

2. TBrowser 的特殊要求：访问权限
TBrowser 在解析类对象时，主要依赖于 Streamer Info。但如果您希望 TBrowser 不仅能显示数据成员，还能通过其内置的机制（如双击绘图）进行交互，需要注意：

非私有成员： 确保您希望在 TBrowser 中查看和交互的数据成员是 public 或 protected 的。虽然 ROOT I/O 机制可以序列化 private 成员（因为它有 Streamer Info 的“特权”），但像 TBrowser 这种通用的交互式工具通常更倾向于查看非私有成员。

🛠️ 满足透明化要求的行动步骤
针对您的情况，您需要检查和修正以下三个方面：

1. 检查字典生成是否完整
回到昨天的讨论，您需要确保您的自定义类是在 ROOT 的构建系统中正确生成了字典的。

正确使用 rootcling： 确保您在编译自定义类库时，运行了 rootcling 命令，并且它成功处理了您的类头文件。

使用 + 标记： 在您的 LinkDef.h 文件中，务必在类名后加上一个加号 +（例如：#pragma link C++ class MyCustomClass+;）。这个 + 标记告诉 rootcling 不仅要生成字典，还要生成Streamer Info。

2. 检查所有嵌套类型是否包含在字典中
如果您的自定义类内部包含其他自定义类、标准容器（如 std::vector）的特定实例化版本，或者来自其他库的 ROOT 可序列化对象（如 TLorentzVector），那么这些嵌套类型也必须有字典。

示例：

如果您的类定义如下：

C++

class MyEvent {
private:
    std::vector<MyHit> fHits; // 内部是一个自定义类
    TLorentzVector fMomentum; // 内部是一个ROOT标准类
    double fEnergy;           // 内部是基础类型
};
您需要在 LinkDef.h 中进行声明：

C++

#pragma link C++ class MyHit+;
#pragma link C++ class MyEvent+;
#pragma link C++ class std::vector<MyHit>+; // 这一行至关重要
// TLorentzVector 通常由 ROOT 自带字典，无需手动声明
如果缺少 std::vector<MyHit>+; 的声明，ROOT 知道 MyEvent 有一个成员叫 fHits，但不知道如何安全地解析 std::vector<MyHit> 内部的元素结构，自然无法在 TBrowser 中展开。

3. 检查库是否被正确加载（Autoloading）
当您打开 .root 文件时，如果文件内的数据依赖于您的自定义类，ROOT 必须知道去哪里找到包含这些类定义的共享库（.so 文件）。

如果 TBrowser 提示找不到类： 在启动 ROOT 之前，确保您的库路径（包含 .so 文件）被加入到 LD_LIBRARY_PATH 环境变量中，并且您的库文件夹中存在 ROOT 自动加载所需的 rootmap 文件。

手动加载： 如果自动加载失败，您可以在 ROOT 命令行中手动加载库：

C++

root [0] gSystem->Load("libMyAnalysis.so");
4. 运行时检查：使用 TClass
您可以在 ROOT 命令行中检查一个类是否成功生成了 Streamer Info：

加载您的库（如果需要）。

获取类的 TClass 对象并检查其 Streamer 信息。

C++

root [0] TClass* cls = TClass::GetClass("MyEvent");
root [1] if (cls) cls->GetStreamerInfo()->Print();
如果 Print() 能够输出详细的类成员列表，则说明 Streamer Info 存在，此时您应该能通过 TBrowser 查看。如果输出为空或报错，则字典生成失败或不完整。

📚 官方信息来源
要深入了解 ROOT 的 I/O 和 Streamer 机制，官方的 ROOT I/O and Persistency Guide 是最重要的参考资料。

ROOT I/O and Persistency Guide - Streamer Information：

https://root.cern/manual/io_persistency/#streamer-information





kndon_smsimulator fix cmake find anaroot

枚举 $TARTSYS/lib 下的 ANAROOT 库。
扩展 CMakeLists.txt 的 find_library 列表，补全必要的 ANAROOT 组件库。
补充 ROOT 的 XML 组件，使 ANAROOT 里依赖的 XML 符号可解析。
重建并确认 simtrace 等目标链接成功。
我做了什么

列出 ANAROOT 库：发现存在 libanacore.so, libanaloop.so, libanacatana.so, libanadali.so, libanasamurai.so, libanabrips.so, libanaespri.so, libanasilicons.so, libanawinds.so 等。
扩展 CMakeLists.txt 的 ANAROOT 搜索：
现在会查找并链接上述组件库（按存在性自动追加到 ANAROOT_LIBRARIES），不仅仅是 anaroot 和 XMLParser。
补充 ROOT 组件：
将 find_package(ROOT REQUIRED COMPONENTS …) 增加 XMLIO 和 XMLParser，以提供 TDOMParser/TXMLDocument/TXMLNode 等符号（ANAROOT 的 anacatana/anasamurai 依赖它们）。
重新配置和构建：
crosssection、get_pdgmass、simtrace 全部已成功链接并构建完成。
目前状态

编译错误已修复，所有相关目标成功构建。
后续如新增 ANAROOT 组件库，当前 CMake 会自动发现并链接（只要库名在列表中）。
可选后续



## 2025-12-11

fix vscode intellisense wrong include path . 

更新了 c_cpp_properties.json:

添加了 "compileCommands" 字段,指向 CMake 生成的编译命令数据库
更新了 C++ 标准为 c++20 (与 CMakeLists.txt 一致)
更新了 CMakeLists.txt:

添加了 set(CMAKE_EXPORT_COMPILE_COMMANDS ON),确保每次 CMake 配置时都生成 compile_commands.json
重新配置了 CMake:

生成了 113KB 的 compile_commands.json 文件,包含所有编译单元的完整信息



buy dpol detector 合同 


```
627*tan(10/180.0*TMath::Pi())
(double) 110.55702
```

![alt text](assets/log202512/image.png)

先加 Neutron exit window,


根据konda 的smsimulator里面各种项目里


```
  //------------------------------ exit window for neutrons
  fExitWindowNConstruction->ConstructSub();
  fExitWindowNConstruction->SetAngle(magAngle);
  fExitWindowNConstruction->PutExitWindow(experimentalHall_log);
  if (fNeutronWinSD==0){
    fNeutronWinSD = new FragmentSD("/NeutronWindow");
    SDMan->AddNewDetector(fNeutronWinSD);
```


```
//------------------------------ exit window for neutrons  
fExitWindowNConstruction->ConstructSub();  
fExitWindowNConstruction->SetAngle(magAngle);  
fExitWindowNConstruction->PutExitWindow(experimentalHall_log);  
  
if (fNeutronWinSD==0){  
  fNeutronWinSD = new FragmentSD("/NeutronWindow");  
  SDMan->AddNewDetector(fNeutronWinSD);  
}  
fExitWindowNConstruction->GetWindowVolume()->SetSensitiveDetector(fNeutronWinSD);
```

需要在头文件中添加的声明
detector construction头文件中需要添加：
```
class ExitWindowNConstruction;  
  
private:  
  ExitWindowNConstruction *fExitWindowNConstruction;  
  G4VSensitiveDetector* fNeutronWinSD;
```

构造函数中的初始化
在构造函数中需要初始化： 

fExitWindowNConstruction = new ExitWindowNConstruction();

析构函数中的清理
在析构函数中需要添加：

delete fExitWindowNConstruction;

发现报错 device 自模块如何集成. 

需要链接smdevices库

在smg4lib里面添加, sim_deuteron里面添加, 相关的cmake语句. 


![alt text](assets/log202512/image-1.png)


## 2025-12-12

添加 charged particle exit window 

 there are 2 exit windows 

 ```
libs/smg4lib/src/devices on  main [✘!?] via △ v3.31.6 via 🐍 v3.13.5 (.venv) 
❯ tree                           
.
├── CMakeLists.txt
├── DipoleConstruction.cc
├── DipoleConstruction.hh
├── DipoleConstructionMessenger.cc
├── DipoleConstructionMessenger.hh
├── ExitWindowC1Construction.cc
├── ExitWindowC1Construction.hh
├── ExitWindowC2Construction.cc
├── ExitWindowC2Construction.hh
├── ExitWindowNConstruction.cc
├── ExitWindowNConstruction.hh
├── MagField.cc
└── MagField.hh
```

C1版本: 主要在simdayone项目中使用 DayoneDetectorConstruction.cc:198-210

C2版本: 在sim_samurai21、sim_tm1510、simtrace等较新项目中使用 SAMURAI21DetectorConstruction.cc:204-213 SimtraceDetectorConstruction.cc:178-187

C2版本，提供了更大的孔径和更稳定的支撑结构;

C1版本: Y方向孔径为40cm (400mm) ExitWindowC1Construction.cc:39-41
C2版本: Y方向孔径为80cm (800mm)，比C1大一倍 ExitWindowC2Construction.cc:43-45




konda 的 simtrace 有c2 

fix Bug. and run 

![alt text](assets/log202512/image-2.png)

cd $SMSIMDIR/work
$SMSIMDIR/sources/build/projects/simtrace/simtrace

don't show window

![alt text](assets/log202512/image-3.png)


![alt text](assets/log202512/image-6.png)


## 2025-12-15

why anaroot on the web 
```
https://ribf.riken.jp/RIBFDAQ/index.php?plugin=attach&refer=Tools%2FAnalysis%2FANAROOT%2FInstallation&openfile=anaroot_v4.6.2.tgz
```
 is different from anaroot in ribdana04
| 对比项 | ribfana04 (本地 ANAROOT) | web ANAROOT |
|---|---|---|
| 构建工具 (Build system) | Autotools | CMake |
| 配置文件 | configure.in + Makefile.am | CMakeLists.txt |
| 学习曲线 | 较陡峭 | 相对平缓 |
| 跨平台 | 优秀 | 优秀 |
| IDE 支持 | 有限 | 原生支持 |
| 依赖检查时机 | 运行时检查 | 配置时检查 |


% kobayashi cite tree

% look for exit window set and rigid accuracacy
% ![alt text](assets/log202512/Map.png)




## 2025-12-16

todo 

- [x] why only simtrace is build after using cmake. default option
- [x]  what is exitwindowc1
- [ ] chekc filter after geo acceptence
- [ ] useing math to estimate the accuracy of reconstructed momentum. of rigid reconstruction

```
### default install projects  ---------------------------
option(use_simtrace "simple simulator of SAMURAI" ON)
option(use_crosssection "crosssection" ON)
option(use_get_pdgmass "get_pdgmass" ON)
```



https://ribf.riken.jp/SAMURAI/120425_SAMURAIConstProp.pdf

https://s3.cern.ch/inspire-prod-files-3/3c4ae5817492ea3c90d12a39dca4014b

https://www.sciencedirect.com/science/article/pii/S0168583X13007118

simdayone c1 exit window 

![alt text](assets/log202512/image-4.png)

![alt text](assets/log202512/image-6.png)


simtrace c2 exit window

![alt text](assets/log202512/image-5.png)



| 对比类型 \ version|c1 | c2 | 评论|
|------------|---|-----|-----|
| 几何主体 | 简单矩形盒子 (window_flange_box) | 带有上下加强肋/管座的复杂布尔体 | V1 结构非常简单，似乎是 V2 的概念简化版或早期原型。V2 更加机械工程化，旨在提高强度。 |
| 主体材料 | 逻辑体材料是 G4_Galactic (真空) | 逻辑体材料是 G4_Fe (铁) | 重要差异！V1 的 window_flange_log 逻辑体材料被错误地设置为真空，而 V2 的主体是铁，意味着 V1 并没有模拟法兰的实体部分，只是一个真空区域。 |
| 窗膜模拟 | 未定义独立的薄膜。中心孔洞 (fWindowHole_log) 被放置在法兰逻辑体内部。 | 未定义独立的薄膜。 | 两个版本都缺乏 V1 (ExitWindowN) 中 3 mm 厚的真实窗膜结构。 |
| 整体尺寸 (X×Y) | 3340.25 mm × 1200 mm | 3340 mm × 1200 mm | 尺寸基本相同，两者都是大型法兰。 |
| 中心孔径 (X×Y) | 2800 mm × 400 mm | 2940 mm × 800 mm | 核心差异！V1 的 Y 方向（垂直）孔径为 400 mm（符合注释中的 40 cm），而 V2 的孔径是 800 mm。 |
| 组件位置 (Z) | 3187.46 mm | 3187.46 mm | 位置完全相同。 |




![alt text](assets/log202512/image-7.png)

the pdc position(boyuan default set) is not good if we use c1 exit window.



![alt text](assets/log202512/image-8.png)


## 2025-12-17

# 

1 画出出经过动量cut 前的 三维分布图, 以及动量cut后的 三维分布图. (pdf 和 html格式都要)

动量cut参考/home/tian/workspace/dpol/smsimulator5.5/scripts/notebooks/input_analysis这里面的cut条件. 可以把动量cut写成一个库函数, 方便以后调用. 写在smsimulator5.5/libs下, 方便之后调用 可以方便读取qmdrawdata smsimulator5.5/data/qmdrawdata . 注意qmdrawdata zpol ypol里面的文件略有差别

2 再画出用经过geometry cut后的三维分布图. (pdf 和 html格式都要)

geometry cut(filter)  需要利用/home/tian/workspace/dpol/smsimulator5.5/libs/geo_accepentce 这个库下面的.  需要按照磁场大小 和 beam 的弯曲角度确定的target位置 进行分类.   需要把不同target位置的geometry cut后的图 (即只记录能同时被pdc 和 nebula被几何接受的动量)都画出来.  而且相关配置得输出成txt文件, pdc 位置也得输出成pdf图片以供查看. 

3 并且画出来Pxp-pxn的count分布图.  (cut前,cut后,geometry cut后)

4 以及画出ratio=(pxp-pxn>0) /() 图. ratio参考

这些图都放在smsimulator5.5/results下面, 按照target gamma分类 还有按照磁场大小 和 beam 的弯曲角度确定的target位置 进行分类 , 命名体现出 是cut前后或者geometry前后.  (ratio图.随着gamma变化趋势 是把不同target的ratio图放在一起对比. 所以就不同分层级)

目录结构
```
smsimulator5.5/results/  
├── [磁场大小]/  
│   ├── [beam转过角度]/   (beam转过角度决定target位置)
|   │   ├── ratio_plots.pdf  (不同靶子 不同pol 的 ratio随着gamma变化趋势图放在一起对比)
|   │   |   ├── [不同target材料]
│   │   │   |   ├── [pol 类型(zpol or ypol)]/
│   │   │   |   | ├── 3d_momentum_before_cuts.[pdf|html]  
│   │   │   |   | ├── 3d_momentum_after_cuts.[pdf|html]  
│   │   │   |   | ├── 3d_momentum_after_geometry.[pdf|html]  
│   │   │   |   | ├── pxp_pxn_distribution_[stage].[pdf|html]  
│   │   │   |   | └── config.txt   ()
```

5 留下接口,使得我可以加入动量的模糊函数,  让我可以测试不同分辨率下 画出来Pxp-pxn的count分布图.  (cut前,cut后,geometry cut后) 画出ratio=(pxp-pxn>0) /(pxp-pxn<0) 

把运行脚本 写在scripts/下面, 运行时候的参数就再写这个脚本里面 让我可以配置 有哪些磁场大小, beam转过角度, target材料, pol类型(zpol or ypol) 以及不同分辨率下的动量模糊函数.  方便我以后直接运行这个脚本就可以生成所有结果.. 




# 编译
cd build && make RunQMDGeoFilter

# 运行
./bin/RunQMDGeoFilter --field 1.0 --angle 5 --target Pb208 --pol zpol --gamma 050 --gamma 060


图例没有安全清除

没有画出来pxp-pxn 分布图(cut 前后 , geometry cut后). 


![alt text](assets/log202512/image-9.png)

![after geo accepentence](assets/log202512/image-10.png)


![alt text](assets/log202512/image-11.png)