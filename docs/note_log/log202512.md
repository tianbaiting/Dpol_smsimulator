# 2025 12 月 notebook

## 2025-12-02

更换了qmd特征动量的大小,从600MeV/c改为627MeV/c,以更好地匹配实验数据.

Changed the QMD characteristic momentum from 600 MeV/c to 627 MeV/c to better match experimental data.

$P = \sqrt{(E)^2 - (m)^2} = \sqrt{(190+938)^2 - (938)^2} MeV/c = 625.5MeV/c$

## 2025-12-03

change homebrew g++ cmake root to conda-forge versions.

use micromaba . .yml to create a env for anaroot . useing root and geant4 in conda-forge

```yml
name: anaroot-env
channels:
  - conda-forge
dependencies:
  - python=3.10
  - cmake
  - make
  - git
  - wget
  - pkg-config
  - gcc_linux-64
  - gxx_linux-64
  - root
  - geant4
  - xerces-c
  - fftw
  - gsl
  - libxml2
  - libpng
  - zlib
  - swig
  - pip
  - xorg-libx11
  - xorg-libxpm
  - xorg-libxft

```

```
# 初始化 micromamba
eval "$(micromamba shell hook -s bash)"  # 或 -s zsh

可选：自动激活 anaroot 环境
micromamba activate anaroot-env
```


direnv is an open-source extension that automatically loads and executes the environment variables and scripts defined in a .envrc file when you enter (cd into) a directory containing one. It automatically unloads those variables when you leave the directory.

```
# Auto-generated .envrc for Dpol_smsimulator
# This file will be executed by direnv when you cd into the project root.
# Ensure micromamba is initialized in this shell (zsh) before using `micromamba activate`.
# Keep this file small and review before allowing with `direnv allow`.

# Initialize micromamba shell hook for zsh (direnv runs this file with your login shell)
if command -v micromamba >/dev/null 2>&1; then
  eval "$(micromamba shell hook --shell zsh)"
fi

# Source the project setup which performs activation and exports variables
if [[ -f ./setup_spana.sh ]]; then
  source ./setup_spana.sh
fi
```


## 2025-12-05

我希望调大动量范围。 

todo 探寻质子动量空间（可被接受的空间）画出三维空间图来，以及做出来此时的pxp-pxn (无模糊 只filter)

取样好还是参数取点好。 

数据的透明选择,root如何做到

I want to increase the momentum range. TODO: Explore the acceptable proton momentum space, visualize it in a 3D plot, and calculate $p_{p} - p_{n}$ (without blurring, only filtering). Which is better: sampling or parametric point scanning?



```bash
root -b -q $ROOTSYS/tutorials/legacy/benchmarks.C > rootbenchmarktest.txt
```

| name | root benchmark | cpu | description |   
|------|-----------------|-----|-------------|
| RIBFANA 04 | 5022 | Intel Xeon Gold 5218 @ 2.30GHz | riken |
| spana03| 4972 | Intel Xeon Platinum 8168 @ 2.70GHz | riken |
| ENPG | 2186 | Intel Xeon E5-2650 v4 @ 2.20GHz | zhigang group |
| SER5 MAX | 19444 | AMD Ryzen 7 5700H | tbt pc |
| Thinkpad X1 Carbon gen10 | 4945 | i7-1260P | tbt pc |

## 2025-12-9

使用hostname 为不同机器加载不同的软件路径

查看root数据文件, 


## 2025-12-10

try to fix root .

.root 文件被 TBrowser 打开 自动展开嵌套, 加载自定义类. 需要利用反射机制. 

geant4 nebula里面似乎没有这样的实现.  


https://tianbaiting.github.io/sci/minimal_code/cernrootData/


提出的这个问题非常关键，它直指 ROOT I/O 的核心——数据透明化（Inspectability），这对于粒子物理学中的数据审查和调试是至关重要的。

您在 TBrowser 中无法查看自定义类内部变量的数值，其根本原因在于 ROOT 缺乏读取和理解该对象内存结构所需的“路线图”。这个“路线图”就是我们昨天谈到的字典以及由它衍生出的 Streamer Information（流信息）。

下面我将详细解释如何满足“透明化”要求，并给出具体的检查步骤。

解决 ROOT 数据透明化的核心方法
要让 TBrowser 或任何 ROOT I/O 函数（如 TTree::Scan()）能够“透明化”地访问自定义 C++ 类的内部变量，必须满足以下两个条件：

1. 确保类和成员变量拥有完整的字典和流信息
流信息（Streamer Information） 是字典机制的核心输出，它包含了 ROOT 在运行时读取和写入对象所需的所有元数据：

类的版本号 (ClassVersion)

所有非 static 和非 transient 的数据成员的列表。

每个数据成员的类型、偏移量（offset in memory）和名称。

如果 Streamer Info 不完整或缺失，TBrowser 只能看到一个抽象的类对象（例如 MyEvent* 或 MyHit），但无法“展开”它来看里面的变量。

2. TBrowser 的特殊要求：访问权限
TBrowser 在解析类对象时，主要依赖于 Streamer Info。但如果您希望 TBrowser 不仅能显示数据成员，还能通过其内置的机制（如双击绘图）进行交互，需要注意：

非私有成员： 确保您希望在 TBrowser 中查看和交互的数据成员是 public 或 protected 的。虽然 ROOT I/O 机制可以序列化 private 成员（因为它有 Streamer Info 的“特权”），但像 TBrowser 这种通用的交互式工具通常更倾向于查看非私有成员。

🛠️ 满足透明化要求的行动步骤
针对您的情况，您需要检查和修正以下三个方面：

1. 检查字典生成是否完整
回到昨天的讨论，您需要确保您的自定义类是在 ROOT 的构建系统中正确生成了字典的。

正确使用 rootcling： 确保您在编译自定义类库时，运行了 rootcling 命令，并且它成功处理了您的类头文件。

使用 + 标记： 在您的 LinkDef.h 文件中，务必在类名后加上一个加号 +（例如：#pragma link C++ class MyCustomClass+;）。这个 + 标记告诉 rootcling 不仅要生成字典，还要生成Streamer Info。

2. 检查所有嵌套类型是否包含在字典中
如果您的自定义类内部包含其他自定义类、标准容器（如 std::vector）的特定实例化版本，或者来自其他库的 ROOT 可序列化对象（如 TLorentzVector），那么这些嵌套类型也必须有字典。

示例：

如果您的类定义如下：

C++

class MyEvent {
private:
    std::vector<MyHit> fHits; // 内部是一个自定义类
    TLorentzVector fMomentum; // 内部是一个ROOT标准类
    double fEnergy;           // 内部是基础类型
};
您需要在 LinkDef.h 中进行声明：

C++

#pragma link C++ class MyHit+;
#pragma link C++ class MyEvent+;
#pragma link C++ class std::vector<MyHit>+; // 这一行至关重要
// TLorentzVector 通常由 ROOT 自带字典，无需手动声明
如果缺少 std::vector<MyHit>+; 的声明，ROOT 知道 MyEvent 有一个成员叫 fHits，但不知道如何安全地解析 std::vector<MyHit> 内部的元素结构，自然无法在 TBrowser 中展开。

3. 检查库是否被正确加载（Autoloading）
当您打开 .root 文件时，如果文件内的数据依赖于您的自定义类，ROOT 必须知道去哪里找到包含这些类定义的共享库（.so 文件）。

如果 TBrowser 提示找不到类： 在启动 ROOT 之前，确保您的库路径（包含 .so 文件）被加入到 LD_LIBRARY_PATH 环境变量中，并且您的库文件夹中存在 ROOT 自动加载所需的 rootmap 文件。

手动加载： 如果自动加载失败，您可以在 ROOT 命令行中手动加载库：

C++

root [0] gSystem->Load("libMyAnalysis.so");
4. 运行时检查：使用 TClass
您可以在 ROOT 命令行中检查一个类是否成功生成了 Streamer Info：

加载您的库（如果需要）。

获取类的 TClass 对象并检查其 Streamer 信息。

C++

root [0] TClass* cls = TClass::GetClass("MyEvent");
root [1] if (cls) cls->GetStreamerInfo()->Print();
如果 Print() 能够输出详细的类成员列表，则说明 Streamer Info 存在，此时您应该能通过 TBrowser 查看。如果输出为空或报错，则字典生成失败或不完整。

📚 官方信息来源
要深入了解 ROOT 的 I/O 和 Streamer 机制，官方的 ROOT I/O and Persistency Guide 是最重要的参考资料。

ROOT I/O and Persistency Guide - Streamer Information：

https://root.cern/manual/io_persistency/#streamer-information





kndon_smsimulator fix cmake find anaroot

枚举 $TARTSYS/lib 下的 ANAROOT 库。
扩展 CMakeLists.txt 的 find_library 列表，补全必要的 ANAROOT 组件库。
补充 ROOT 的 XML 组件，使 ANAROOT 里依赖的 XML 符号可解析。
重建并确认 simtrace 等目标链接成功。
我做了什么

列出 ANAROOT 库：发现存在 libanacore.so, libanaloop.so, libanacatana.so, libanadali.so, libanasamurai.so, libanabrips.so, libanaespri.so, libanasilicons.so, libanawinds.so 等。
扩展 CMakeLists.txt 的 ANAROOT 搜索：
现在会查找并链接上述组件库（按存在性自动追加到 ANAROOT_LIBRARIES），不仅仅是 anaroot 和 XMLParser。
补充 ROOT 组件：
将 find_package(ROOT REQUIRED COMPONENTS …) 增加 XMLIO 和 XMLParser，以提供 TDOMParser/TXMLDocument/TXMLNode 等符号（ANAROOT 的 anacatana/anasamurai 依赖它们）。
重新配置和构建：
crosssection、get_pdgmass、simtrace 全部已成功链接并构建完成。
目前状态

编译错误已修复，所有相关目标成功构建。
后续如新增 ANAROOT 组件库，当前 CMake 会自动发现并链接（只要库名在列表中）。
可选后续



## 2025-12-11

fix vscode intellisense wrong include path . 

更新了 c_cpp_properties.json:

添加了 "compileCommands" 字段,指向 CMake 生成的编译命令数据库
更新了 C++ 标准为 c++20 (与 CMakeLists.txt 一致)
更新了 CMakeLists.txt:

添加了 set(CMAKE_EXPORT_COMPILE_COMMANDS ON),确保每次 CMake 配置时都生成 compile_commands.json
重新配置了 CMake:

生成了 113KB 的 compile_commands.json 文件,包含所有编译单元的完整信息



buy dpol detector 合同 


```
627*tan(10/180.0*TMath::Pi())
(double) 110.55702
```

![alt text](assets/log202512/image.png)

先加 Neutron exit window,


根据konda 的smsimulator里面各种项目里


```
  //------------------------------ exit window for neutrons
  fExitWindowNConstruction->ConstructSub();
  fExitWindowNConstruction->SetAngle(magAngle);
  fExitWindowNConstruction->PutExitWindow(experimentalHall_log);
  if (fNeutronWinSD==0){
    fNeutronWinSD = new FragmentSD("/NeutronWindow");
    SDMan->AddNewDetector(fNeutronWinSD);
```


```
//------------------------------ exit window for neutrons  
fExitWindowNConstruction->ConstructSub();  
fExitWindowNConstruction->SetAngle(magAngle);  
fExitWindowNConstruction->PutExitWindow(experimentalHall_log);  
  
if (fNeutronWinSD==0){  
  fNeutronWinSD = new FragmentSD("/NeutronWindow");  
  SDMan->AddNewDetector(fNeutronWinSD);  
}  
fExitWindowNConstruction->GetWindowVolume()->SetSensitiveDetector(fNeutronWinSD);
```

需要在头文件中添加的声明
detector construction头文件中需要添加：
```
class ExitWindowNConstruction;  
  
private:  
  ExitWindowNConstruction *fExitWindowNConstruction;  
  G4VSensitiveDetector* fNeutronWinSD;
```

构造函数中的初始化
在构造函数中需要初始化： 

fExitWindowNConstruction = new ExitWindowNConstruction();

析构函数中的清理
在析构函数中需要添加：

delete fExitWindowNConstruction;

发现报错 device 自模块如何集成. 

需要链接smdevices库

在smg4lib里面添加, sim_deuteron里面添加, 相关的cmake语句. 


![alt text](assets/log202512/image-1.png)


## 2025-12-12

添加 charged particle exit window 

 there are 2 exit windows 

 ```
libs/smg4lib/src/devices on  main [✘!?] via △ v3.31.6 via 🐍 v3.13.5 (.venv) 
❯ tree                           
.
├── CMakeLists.txt
├── DipoleConstruction.cc
├── DipoleConstruction.hh
├── DipoleConstructionMessenger.cc
├── DipoleConstructionMessenger.hh
├── ExitWindowC1Construction.cc
├── ExitWindowC1Construction.hh
├── ExitWindowC2Construction.cc
├── ExitWindowC2Construction.hh
├── ExitWindowNConstruction.cc
├── ExitWindowNConstruction.hh
├── MagField.cc
└── MagField.hh
```

C1版本: 主要在simdayone项目中使用 DayoneDetectorConstruction.cc:198-210

C2版本: 在sim_samurai21、sim_tm1510、simtrace等较新项目中使用 SAMURAI21DetectorConstruction.cc:204-213 SimtraceDetectorConstruction.cc:178-187

C2版本，提供了更大的孔径和更稳定的支撑结构;

C1版本: Y方向孔径为40cm (400mm) ExitWindowC1Construction.cc:39-41
C2版本: Y方向孔径为80cm (800mm)，比C1大一倍 ExitWindowC2Construction.cc:43-45




konda 的 simtrace 有c2 

fix Bug. and run 

![alt text](assets/log202512/image-2.png)

cd $SMSIMDIR/work
$SMSIMDIR/sources/build/projects/simtrace/simtrace

don't show window

![alt text](assets/log202512/image-3.png)